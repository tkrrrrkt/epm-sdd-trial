# Kiro Spec-Driven Development ヘルプ

Kiro-style Spec Driven Development (SDD) のコマンドリファレンスです。

## 目次

- [概要](#概要)
- [ワークフロー](#ワークフロー)
- [コマンド一覧](#コマンド一覧)
  - [Phase 0: Steering（プロジェクト設定）](#phase-0-steeringプロジェクト設定)
  - [Phase 1: Specification（仕様定義）](#phase-1-specification仕様定義)
  - [Phase 2: Implementation（実装）](#phase-2-implementation実装)
  - [Status & Validation（ステータス確認・検証）](#status--validationステータス確認検証)
- [よくある質問](#よくある質問)

---

## 概要

Kiro SDDは、AI-DLC（AI Development Life Cycle）における仕様駆動開発の実装です。3段階の承認ワークフロー（要件 → 設計 → タスク → 実装）を通じて、体系的な開発を支援します。

### ディレクトリ構造

```
.kiro/
├── steering/          # プロジェクト全体のルールとコンテキスト
│   ├── product.md     # プロダクト情報
│   ├── tech.md        # 技術スタック
│   ├── structure.md   # プロジェクト構造
│   └── *.md           # カスタムステアリング
└── specs/             # 機能ごとの仕様
    └── <feature-name>/
        ├── spec.json      # メタデータ
        ├── requirements.md # 要件定義
        ├── design.md      # 技術設計
        ├── tasks.md       # 実装タスク
        └── research.md    # 調査ログ（オプション）
```

### 基本原則

- **段階的承認**: 各フェーズで人間のレビューが必要（`-y`フラグで自動承認可能）
- **仕様駆動**: 要件 → 設計 → タスク → 実装の順序を厳守
- **プロジェクトメモリ**: `.kiro/steering/`がプロジェクト全体の知識として機能

---

## ワークフロー

### 最小ワークフロー

```
Phase 0 (オプション): プロジェクト設定
  ├─ /kiro/steering              # ステアリング生成/更新
  └─ /kiro/steering-custom       # カスタムステアリング作成

Phase 1: 仕様定義
  ├─ /kiro/spec-init "説明"      # 仕様の初期化
  ├─ /kiro/spec-requirements <feature>  # 要件定義
  ├─ /kiro/validate-gap <feature>      # ギャップ分析（オプション）
  ├─ /kiro/spec-design <feature> [-y]  # 技術設計
  ├─ /kiro/validate-design <feature>   # 設計レビュー（オプション）
  └─ /kiro/spec-tasks <feature> [-y]   # 実装タスク生成

Phase 2: 実装
  ├─ /kiro/spec-impl <feature> [tasks]  # 実装実行
  └─ /kiro/validate-impl <feature>       # 実装検証（オプション）

ステータス確認（いつでも使用可能）
  └─ /kiro/spec-status <feature>  # 進捗確認
```

---

## コマンド一覧

### Phase 0: Steering（プロジェクト設定）

#### `/kiro/steering`

プロジェクト全体のステアリング（プロジェクトメモリ）を管理します。

**機能**:
- **Bootstrap Mode**: `.kiro/steering/`が空またはコアファイル（product.md, tech.md, structure.md）が不足している場合、コードベースから自動生成
- **Sync Mode**: 既存のステアリングをコードベースと同期し、ドリフトを検出

**使用例**:
```
/kiro/steering
```

**出力**:
- Bootstrap: 生成されたファイルの概要
- Sync: 更新内容、コードドリフト警告、推奨事項

**注意**:
- ユーザーのカスタマイズは保持されます（追加のみ、置換なし）
- パターンと原則を記録し、ファイル/依存関係の完全なリストは作成しません

---

#### `/kiro/steering-custom`

ドメイン固有のカスタムステアリングドキュメントを作成します。

**機能**:
- カスタムステアリングの作成（API標準、テスト、セキュリティなど）
- テンプレートベースの生成（利用可能な場合）

**利用可能なテンプレート**:
- `api-standards.md` - REST/GraphQL規約、エラーハンドリング
- `testing.md` - テスト組織、モック、カバレッジ
- `security.md` - 認証パターン、入力検証、シークレット
- `database.md` - スキーマ設計、マイグレーション、クエリパターン
- `error-handling.md` - エラータイプ、ロギング、リトライ戦略
- `authentication.md` - 認証フロー、権限、セッション管理
- `deployment.md` - CI/CD、環境、ロールバック手順

**使用例**:
```
/kiro/steering-custom
```

**対話的**: ユーザーにドメイン/トピックと要件を尋ねます

---

### Phase 1: Specification（仕様定義）

#### `/kiro/spec-init "プロジェクト説明"`

新しい仕様を初期化します。

**機能**:
- プロジェクト説明から機能名を生成
- 仕様ディレクトリ構造を作成
- `spec.json`と`requirements.md`の初期ファイルを生成

**使用例**:
```
/kiro/spec-init "ユーザー認証システムの実装"
```

**出力**:
- 生成された機能名（`feature-name`形式）
- 作成されたファイルのパス
- 次のステップ（`/kiro/spec-requirements`）

**注意**:
- この段階では要件/設計/タスクは生成されません
- 厳密なフェーズ分離を維持

---

#### `/kiro/spec-requirements <feature-name>`

要件定義ドキュメントを生成します。

**機能**:
- プロジェクト説明から包括的な要件を生成
- EARS形式の受け入れ基準を適用
- 要件を論理的なグループに分類

**使用例**:
```
/kiro/spec-requirements user-auth
```

**出力**:
- 主要な要件領域の概要（3-5箇条）
- 更新されたファイルの確認
- 次のステップ（承認と継続、または修正）

**注意**:
- **WHAT**に焦点（実装詳細は含めない）
- 要件はテスト可能で検証可能である必要があります
- 要件見出しには数値IDのみを使用（例: "Requirement 1", "1.", "2 Feature ..."）

**次のフェーズ**:
- 要件承認後: `/kiro/spec-design <feature> -y`で設計フェーズへ
- 修正が必要: フィードバックを提供し、`/kiro/spec-requirements <feature>`を再実行

---

#### `/kiro/validate-gap <feature-name>`

既存コードベースと要件の間の実装ギャップを分析します。

**機能**:
- 既存コードベースパターンとコンポーネントの包括的理解
- 不足している機能と統合課題の明確な識別
- 複数の実装アプローチの評価
- 設計フェーズで必要な技術調査の特定

**使用例**:
```
/kiro/validate-gap user-auth
```

**出力**:
- 分析サマリー（範囲、課題、推奨事項）
- 詳細なギャップ分析ドキュメント

**注意**:
- **オプション**: 既存コードベース（brownfield）プロジェクトに推奨
- グリーンフィールドプロジェクトではスキップ可能
- 決定ではなく情報を提供（複数のオプションを提示）

**次のフェーズ**:
- ギャップ分析完了後: `/kiro/spec-design <feature>`で技術設計を作成

---

#### `/kiro/spec-design <feature-name> [-y]`

技術設計ドキュメントを生成します。

**機能**:
- 要件（WHAT）を技術設計（HOW）に変換
- 適切なアーキテクチャ発見と調査を実行
- ステアリングコンテキストと既存パターンに整合
- 複雑なアーキテクチャには視覚的な図を含める

**使用例**:
```
/kiro/spec-design user-auth
/kiro/spec-design user-auth -y  # 要件を自動承認して続行
```

**フラグ**:
- `-y`: 要件を自動承認して設計生成を続行

**発見プロセス**:
- **新機能**（グリーンフィールド）→ 完全な発見が必要
- **拡張**（既存システム）→ 統合中心の発見
- **単純な追加**（CRUD/UI）→ 最小限または発見なし
- **複雑な統合**→ 包括的な分析が必要

**出力**:
- 設計ドキュメント生成の確認
- 実行された発見タイプ（full/light/minimal）
- 設計を形成した重要な洞察（2-3点）
- 承認ワークフローガイダンス

**注意**:
- **型安全性**: プロジェクトの技術スタックに合わせた強い型付けを強制
- **最新情報**: 外部依存関係とベストプラクティスにはWebSearch/WebFetchを使用
- **要件トレーサビリティID**: 数値要件IDのみを使用（例: "1.1", "1.2", "3.1"）

**次のフェーズ**:
- 設計承認後: `/kiro/spec-tasks <feature> -y`で実装タスクを生成
- 修正が必要: フィードバックを提供し、`/kiro/spec-design <feature>`を再実行

---

#### `/kiro/validate-design <feature-name>`

技術設計の品質レビューと検証を実行します。

**機能**:
- 実装準備のための対話的な品質レビュー
- 重要な問題の識別（最大3つ）
- 強みと弱みのバランス評価
- 明確なGO/NO-GO決定と根拠

**使用例**:
```
/kiro/validate-design user-auth
```

**出力**:
- レビューサマリー（設計品質と準備状況の概要）
- 重要な問題（最大3つ）
- 設計の強み（1-2点）
- 最終評価（GO/NO-GO決定と次のステップ）

**注意**:
- **品質保証、完璧主義ではない**: 許容可能なリスクを受け入れる
- **重要な問題のみ**: 最大3つの問題、成功に大きく影響するもののみ
- **対話的アプローチ**: 一方向の評価ではなく、対話に従事

**次のフェーズ**:
- **GO決定**: `/kiro/spec-tasks <feature> -y`で実装タスクを生成
- **NO-GO決定**: 識別された重要な問題に対処し、`/kiro/spec-design <feature>`を再実行

---

#### `/kiro/spec-tasks <feature-name> [-y] [--sequential]`

実装タスクを生成します。

**機能**:
- 技術設計を実行可能な作業項目に変換
- すべての要件を特定のタスクにマッピング
- 適切なサイズのタスク（各1-3時間）
- 明確なタスク進行と適切な階層

**使用例**:
```
/kiro/spec-tasks user-auth
/kiro/spec-tasks user-auth -y              # 要件と設計を自動承認
/kiro/spec-tasks user-auth -y --sequential # シーケンシャルモード（並列マーカーなし）
```

**フラグ**:
- `-y`: 要件と設計を自動承認してタスク生成を続行
- `--sequential`: シーケンシャルモード（並列タスクマーカー`(P)`を省略）

**出力**:
- タスク生成の確認
- タスクサマリー（主要タスク数、サブタスク数、要件カバレッジ）
- 品質検証（要件マッピング、タスク依存関係、テストタスク）
- 次のアクション

**注意**:
- **完全なカバレッジ**: すべての要件がタスクにマッピングされる必要があります
- **最大2レベル**: 主要タスクとサブタスクのみ（より深いネストなし）
- **自然言語**: 何をするかを記述し、コード構造の詳細は含めない
- **並列マーカー**: `(P)`マーカーは並列基準を満たすタスクに適用（シーケンシャルモードでは省略）

**次のフェーズ**:
- **実装開始前**: 会話履歴をクリアしてコンテキストを解放（推奨）
- **タスク承認後**:
  - 特定のタスク: `/kiro/spec-impl <feature> 1.1`（各タスク間でコンテキストをクリアすることを推奨）
  - 複数のタスク: `/kiro/spec-impl <feature> 1.1,1.2`（慎重に使用、タスク間でコンテキストをクリア）
  - すべてのタスク: `/kiro/spec-impl <feature>`（コンテキスト肥大化のため非推奨）

---

### Phase 2: Implementation（実装）

#### `/kiro/spec-impl <feature-name> [task-numbers]`

TDD（テスト駆動開発）手法を使用して実装タスクを実行します。

**機能**:
- 承認された仕様に基づいてTDD手法で実装タスクを実行
- Kent BeckのTDDサイクル（RED → GREEN → REFACTOR → VERIFY）に従う
- タスク完了時に`tasks.md`を更新

**使用例**:
```
/kiro/spec-impl user-auth 1.1              # 単一タスク
/kiro/spec-impl user-auth 1.1,1.2          # 複数タスク
/kiro/spec-impl user-auth                  # すべての保留タスク（非推奨）
```

**TDDサイクル**:
1. **RED**: 失敗するテストを書く（コードはまだ存在しない）
2. **GREEN**: テストを通す最小限のコードを書く
3. **REFACTOR**: コード構造と可読性を改善
4. **VERIFY**: すべてのテストが通過することを確認
5. **MARK COMPLETE**: `tasks.md`でチェックボックスを更新

**出力**:
- 実行されたタスクとテスト結果
- 完了したタスクの確認、残りのタスク数

**注意**:
- **TDD必須**: 実装コードの前にテストを書く必要があります
- **タスクスコープ**: 特定のタスクが必要とするもののみを実装
- **テストカバレッジ**: すべての新しいコードにテストが必要
- **リグレッションなし**: 既存のテストが引き続き通過する必要があります

**実装前の推奨事項**:
- 会話履歴をクリアしてコンテキストを解放
- 最初のタスクを開始する場合、またはタスク間で切り替える場合に適用

---

#### `/kiro/validate-impl [feature-name] [task-numbers]`

実装が要件、設計、タスクに整合していることを検証します。

**機能**:
- 実装の包括的な検証
- タスク完了、テストカバレッジ、要件トレーサビリティ、設計整合性を確認
- リグレッション検出

**使用例**:
```
/kiro/validate-impl                        # 自動検出（会話履歴から）
/kiro/validate-impl user-auth              # 機能のすべての完了タスク
/kiro/validate-impl user-auth 1.1,1.2      # 特定のタスク
```

**検証項目**:
- **タスク完了チェック**: `tasks.md`でチェックボックスが`[x]`であることを確認
- **テストカバレッジ**: タスク関連機能のテストが存在し、通過することを確認
- **要件トレーサビリティ**: EARS要件がコードにトレーサブルであることを確認
- **設計整合性**: `design.md`構造が実装に反映されていることを確認
- **リグレッションチェック**: 既存のテストが壊れていないことを確認

**出力**:
- 検出されたターゲット（自動検出の場合）
- 検証サマリー（機能ごとのパス/失敗数）
- 問題リスト（重大度と場所付き）
- カバレッジレポート（要件/設計/タスクのカバレッジ率）
- 決定（GO: 次のフェーズ準備完了 / NO-GO: 修正が必要）

**注意**:
- **会話認識**: 自動検出のために会話履歴を優先
- **非ブロッキング警告**: 設計の偏差は警告（重大でない限り）
- **テスト優先**: テストカバレッジはGO決定に必須
- **トレーサビリティ必須**: すべての要件が実装にトレーサブルである必要があります

**次のステップ**:
- **GO決定**: 実装が検証され、準備完了
- **NO-GO決定**: リストされた重要な問題に対処し、`/kiro/validate-impl`を再実行

---

### Status & Validation（ステータス確認・検証）

#### `/kiro/spec-status <feature-name>`

仕様のステータスと進捗を表示します。

**機能**:
- すべてのフェーズにわたる包括的なステータスと進捗の表示
- 現在のフェーズと完了ステータスの識別
- 次のアクションとブロッカーの特定

**使用例**:
```
/kiro/spec-status user-auth
```

**出力**:
- **機能概要**: 名前、フェーズ、最終更新日時
- **フェーズステータス**: 要件、設計、タスク（完了率%）
- **タスク内訳**: タスクが存在する場合、完了/残りのカウント
- **次のアクション**: 次に実行する必要があるコマンド
- **ブロッカー**: 進捗を妨げている問題

**注意**:
- いつでも使用可能（実装中でも）
- `spec.json`で指定された言語で出力

---

## よくある質問

### Q: `-y`フラグはいつ使用すべきですか？

A: `-y`フラグは、意図的な高速化のために使用します。通常のワークフローでは、各フェーズで人間のレビューが必要です。`-y`を使用すると、前のフェーズが自動承認されます。

### Q: 既存のコードベースで作業する場合、どのコマンドから始めますか？

A: 既存のコードベース（brownfield）プロジェクトでは、`/kiro/validate-gap`を要件定義後に実行することを推奨します。これにより、実装戦略を通知するギャップ分析が提供されます。

### Q: 実装中にコンテキストをクリアする必要があるのはなぜですか？

A: コンテキストの肥大化を防ぎ、各タスクに適切に焦点を当てるためです。特に複数のタスクを実行する場合、タスク間でコンテキストをクリアすることを推奨します。

### Q: 並列タスクマーカー`(P)`とは何ですか？

A: `(P)`マーカーは、並列実行可能なタスクを示します。`--sequential`フラグを使用すると、これらのマーカーは省略されます。

### Q: 要件IDは数値のみですか？

A: はい。要件見出しには数値IDのみを使用します（例: "Requirement 1", "1.", "2 Feature ..."）。アルファベットID（例: "Requirement A"）は使用しません。

### Q: ステアリングと仕様の違いは何ですか？

A: **Steering** (`.kiro/steering/`) はプロジェクト全体のルールとコンテキストをガイドします。**Specs** (`.kiro/specs/`) は個々の機能の開発プロセスを形式化します。

### Q: カスタムステアリングはどのように管理されますか？

A: `/kiro/steering-custom`を使用してカスタムステアリングを作成します。すべての`.kiro/steering/*.md`ファイルは、コアファイル（product.md, tech.md, structure.md）と同様にプロジェクトメモリとして扱われます。

---

## 関連リソース

- **プロジェクト設定**: `.kiro/steering/`
- **仕様**: `.kiro/specs/<feature-name>/`
- **ステータス確認**: `/kiro/spec-status <feature-name>`

---

**最終更新**: 2024年

